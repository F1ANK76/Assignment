# C++ 게임 개발자를 위한 코딩 테스트 관련 핵심 주제

## 1. STL 기본 컨테이너
- **정의**: C++에서 자주 사용하는 자료구조인 `vector`, `stack`, `queue`, `deque` 등 기본 컨테이너들  
- **필요 상황**: 데이터의 삽입/삭제 위치나 순서, 접근 방식이 중요한 문제에서 선택적으로 사용  
- **핵심 포인트**: 컨테이너마다 시간복잡도와 내부 구조가 다르므로, 문제에 따라 최적의 선택이 중요

## 2. map & set 계열 (해시 테이블 포함)
- **정의**: 키-값 저장 구조(`map`, `unordered_map`)와 중복 없는 집합 구조(`set`, `unordered_set`)  
- **필요 상황**: 키 기반 탐색, 중복 제거, 빈도수 세기, 빠른 조회나 정렬이 필요한 문제  
- **핵심 포인트**:  
    - `map`, `set`은 트리 기반 → O(log N), 정렬 유지  
  - `unordered_` 계열은 해시 기반 → 평균 O(1), 정렬 없음  
  - 목적에 따라 트리냐 해시냐를 구분해 사용

## 3. priority_queue와 다익스트라
- **정의**: 우선순위가 높은 데이터를 먼저 꺼낼 수 있는 힙 기반의 큐 + 다익스트라는 최단 거리 탐색 알고리즘  
- **필요 상황**: 가장 작은(또는 큰) 값을 반복적으로 선택해야 하는 문제, 특히 최단 거리 탐색  
- **핵심 포인트**:  
  - 다익스트라는 "가장 짧은 거리 노드"를 계속 선택해야 하므로 최소 힙이 필수  
  - `priority_queue`는 기본적으로 최대 힙 → 최소 힙으로 바꾸기 위해 `greater<자료형>` 사용

## 4. STL 알고리즘 함수 활용 (정렬 포함)
- **정의**: C++ STL이 제공하는 표준 알고리즘 함수들 (`sort`, `binary_search`, `lower_bound` 등)  
- **필요 상황**: 정렬, 탐색, 순열 생성 등 반복적으로 등장하는 전형적인 문제들  
- **핵심 포인트**:  
  - STL 알고리즘은 빠르고 안전하며, 재사용성이 높음  
  - 사용자 정의 정렬 기준(`compare 함수`)을 자유자재로 다룰 수 있어야 응용이 가능

## 5. 브루트포스
- **정의**: 가능한 모든 경우를 전부 시도해 정답을 찾는 완전탐색 방식  
- **필요 상황**: 문제 크기가 작거나, 최적화보다 정확한 답이 우선일 때  
- **핵심 포인트**:  
  - 조건 없는 무작정 탐색이지만, 작고 단순한 문제에서 강력함  
  - STL의 `next_permutation`이나 조합 로직과 함께 자주 사용

## 6. 백트래킹
- **정의**: 조건에 맞지 않는 경우의 수를 조기에 배제하며 탐색하는 가지치기 완전탐색  
- **필요 상황**: 중복 없이 모든 조합/순열을 탐색하거나 조건을 만족하는 경로만 찾을 때  
- **핵심 포인트**:  
  - 재귀 기반 탐색 + 조건 분기 → 효율적으로 경우 수를 줄일 수 있음  
  - 방문 여부, 조건 체크 로직이 정확해야 불필요한 탐색을 방지 가능

## 7. 트리, 그래프, DFS/BFS 탐색
- **정의**: 정점과 간선으로 이루어진 자료구조(그래프)와 그 위에서 동작하는 탐색 알고리즘들  
- **필요 상황**: 노드 간 연결 관계 탐색, 경로 찾기, 거리 계산, 순환 여부 확인 등  
- **핵심 포인트**:  
  - DFS : 깊이 우선 탐색 → 재귀/스택  
  - BFS : 너비 우선 탐색 → 큐  
  - 문제의 구조와 요구사항에 맞는 탐색 방식 선택이 중요

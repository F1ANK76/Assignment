# C++ 게임 개발자를 위한 코딩 테스트 관련 핵심 내용

## 1. STL 기본 컨테이너
- **정의** : C++에서 자주 사용하는 자료구조인 `vector`, `stack`, `queue` 등 기본 컨테이너들을 의미
- **핵심 포인트**
  - vector: 인덱스를 통해 빠른 임의 접근이 필요한 경우 사용. 배열처럼 크기가 가변적인 자료구조가 필요할 때 적합
  - stack: 후입선출(LIFO) 방식이 필요한 경우 사용. 최근 상태나 경로 추적이 필요할 때 적합. DFS, 괄호 검사 등에서 유용
  - queue: 선입선출(FIFO) 방식이 필요한 경우 사용. 순차적으로 작업을 처리하거나 이벤트를 처리할 때 적합. BFS, 작업 대기열 처리 등에 유용
  
## 2. map & set 계열
- **정의** : 키-값 쌍 및 중복 없는 집합을 저장하는 자료구조로, unordered_map과 unordered_set은 해시 테이블을 이용해 순서 없이 빠른 검색을 제공
- **핵심 포인트**
  - map: 키-값 쌍을 저장하고 정렬된 상태로 접근해야 할 때 사용. 빈도수 세기, 값에 따른 정렬 필요, 키-값 매핑이 필요한 경우에 유용
  - set: 중복 없는 값을 정렬된 상태로 저장해야 할 때 사용. 중복 제거, 정렬된 상태 유지 필요시 유용
  - unordered_map, unordered_set: 키-값 쌍 또는 중복 없는 값을 순서와 상관없이 빠르게 저장하고 조회해야 할 때 사용

## 3. STL 알고리즘 함수 활용
- **정의** : C++ STL이 제공하는 표준 알고리즘 함수들을 의미 (`sort`, `accumulate`, `reverse` 등)  
- **핵심 포인트**
  - sort : 범위 정렬. 기본은 오름차순. compare 함수로 기준 커스터마이징 가능
  - accumulate : 컨테이너 내 원소들의 누적합 계산
  - reverse : 범위 뒤집기

## 4. 브루트포스
- **정의** : 가능한 모든 경우의 수를 전부 탐색하여 정답을 찾는 완전탐색 기법
- **핵심 포인트**:  
  - 가능한 경우의 수가 작고 제한적일 때, 정답을 얻기 위해서는 직접 시도해보는 수밖에 없을 때, 복잡한 로직 없이 직관적으로 경우를 열거할 수 있을 때 사용
  - 모든 조합이나 순열, 좌표, 구간, 조건 등을 직접 탐색해 정답을 도출해야 하는 문제에 적합
  - 예시 : 주어진 배열에서 두 수를 더해서 목표값을 만드는 두 수의 인덱스를 찾는 문제를 브루트포스 방식으로 해결할 수 있음

```
vector<int> twoSum(vector<int> nums, int target) {
    vector<int> result;

    // 모든 가능한 두 수의 조합을 검사
    for (int i = 0; i < nums.size(); ++i) {
        for (int j = i + 1; j < nums.size(); ++j) {

            if (nums[i] + nums[j] == target) {
                result.push_back(i);
                result.push_back(j);
                return result;
            }
        }
    }

    return result;
}
```

## 5. 백트래킹
- **정의** : 조건을 만족하지 않는 경로는 미리 제외하면서 탐색하는 가지치기 기반의 완전탐색 기법
- **핵심 포인트**:
  - 문제 해결 과정에서 가지치기가 필요하고, 효율적인 탐색을 위해 불필요한 경로를 미리 배제할 때 유용
  - 조합, 순열, 부분집합 탐색 문제, 최적화 문제, 경로 탐색 문제 등에 사용
  - 예시 : 같은 숫자를 여러 번 사용할 수 있는 조합 중에서 합이 target이 되는 경우의 수 개수 구하기
 
```
void backtrack(vector<int> nums, vector<int> path, int target) {
    int total = accumulate(path.begin(), path.end(), 0);

    if (total > target) return;        // 조건 안 맞으면 중단
    if (total == target) {             // 조건 맞으면 정답 증가
        answer++;
        return;
    }

    for (int i = 0; i < nums.size(); i++) {
        path.push_back(nums[i]);       // 선택
        backtrack(nums, path, target); // 다음 단계로
        path.pop_back();               // 백트랙
    }
}
```

## 6. 트리, 그래프, DFS/BFS 탐색
- **정의**
  - 트리 : 루트 노드에서 시작해 자식 노드들로 이어지는 계층적 구조를 가지는 자료구조
  - 그래프 : 정점(노드)과 간선(연결선)으로 이루어진 자료구조로, 방향이 있을 수도 없을 수도 있음
  - DFS(깊이 우선 탐색) : 현재 정점에서 더 깊은 정점으로 계속 탐색하며, 탐색이 끝난 후에는 다시 돌아와 다른 경로를 탐색하는 방식
  - BFS(너비 우선 탐색) : 현재 정점에서 시작해 인접한 정점들을 먼저 탐색하고, 그 후 그들의 인접한 정점들을 탐색하는 방식.
    
- **핵심 포인트**:  
  - 트리 : 이진 탐색 트리에서의 검색/삽입/삭제, 이진 트리의 최대 깊이 구하기 등의 문제에서 사용
  - 그래프 : 다익스트라 알고리즘을 이용한 최단 경로 찾기, BFS나 DFS를 이용한 그래프의 연결 요소 구하기 등의 문제에서 사용
  - DFS(깊이 우선 탐색) : 미로 탈출 경로 찾기, 부분 문제에서 가능한 모든 조합을 찾는 문제 등에서 사용
  - BFS(너비 우선 탐색) : 최단 경로 문제, 층별 탐색 등의 문제에서 사용

## 7. 다익스트라
- **정의** : 가중치 그래프에서 한 정점으로부터 다른 모든 정점까지의 최단 거리를 구하는 알고리즘
- **핵심 포인트**
  - 가중치 그래프에서 시작점과 다른 모든 정점 간의 최단 거리를 계산할 때 사용
  - 최단 경로 문제, 지하철 노선 최적화, 네트워크 연결 문제 등에서 사용


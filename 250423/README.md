# C++ 게임 개발자를 위한 코딩 테스트 관련 핵심 주제

## 1. STL 기본 컨테이너
- **정의** : C++에서 자주 사용하는 자료구조인 `vector`, `stack`, `queue` 등 기본 컨테이너들을 의미
- **핵심 포인트**
  - vector: 인덱스를 통해 빠른 임의 접근이 필요한 경우 사용. 배열처럼 크기가 가변적인 자료구조가 필요할 때 적합
  - stack: 후입선출(LIFO) 방식이 필요한 경우 사용. 최근 상태나 경로 추적이 필요할 때 적합. DFS, 괄호 검사 등에서 유용함
  - queue: 선입선출(FIFO) 방식이 필요한 경우 사용. 순차적으로 작업을 처리하거나 이벤트를 처리할 때 적합. BFS, 작업 대기열 처리 등에 유용함
  
## 2. map & set 계열
- **정의** : 키-값 쌍 및 중복 없는 집합을 저장하는 자료구조로, unordered_map과 unordered_set은 해시 테이블을 이용해 순서 없이 빠른 검색을 제공
- **핵심 포인트** : 정렬 여부, 검색 성능, 데이터 중복 여부 등을 고려하여 선택
  - map: 키-값 쌍을 저장하고 정렬된 상태로 접근해야 할 때 사용
  - set: 중복 없는 값을 정렬된 상태로 저장해야 할 때 사용
  - unordered_map, unordered_set: 키-값 쌍 또는 중복 없는 값을 순서와 상관없이 빠르게 저장하고 조회해야 할 때 사용

## 3. priority_queue와 다익스트라
- **정의**: 우선순위가 높은 데이터를 먼저 꺼낼 수 있는 힙 기반의 큐 + 다익스트라는 최단 거리 탐색 알고리즘  
- **필요 상황**: 가장 작은(또는 큰) 값을 반복적으로 선택해야 하는 문제, 특히 최단 거리 탐색  
- **핵심 포인트**:  
  - 다익스트라는 "가장 짧은 거리 노드"를 계속 선택해야 하므로 최소 힙이 필수  
  - `priority_queue`는 기본적으로 최대 힙 → 최소 힙으로 바꾸기 위해 `greater<자료형>` 사용

## 4. STL 알고리즘 함수 활용 (정렬 포함)
- **정의**: C++ STL이 제공하는 표준 알고리즘 함수들 (`sort`, `binary_search`, `lower_bound` 등)  
- **필요 상황**: 정렬, 탐색, 순열 생성 등 반복적으로 등장하는 전형적인 문제들  
- **핵심 포인트**:  
  - STL 알고리즘은 빠르고 안전하며, 재사용성이 높음  
  - 사용자 정의 정렬 기준(`compare 함수`)을 자유자재로 다룰 수 있어야 응용이 가능

## 5. 브루트포스
- **정의**: 가능한 모든 경우를 전부 시도해 정답을 찾는 완전탐색 방식  
- **필요 상황**: 문제 크기가 작거나, 최적화보다 정확한 답이 우선일 때  
- **핵심 포인트**:  
  - 조건 없는 무작정 탐색이지만, 작고 단순한 문제에서 강력함  
  - STL의 `next_permutation`이나 조합 로직과 함께 자주 사용

## 6. 백트래킹
- **정의**: 조건에 맞지 않는 경우의 수를 조기에 배제하며 탐색하는 가지치기 완전탐색  
- **필요 상황**: 중복 없이 모든 조합/순열을 탐색하거나 조건을 만족하는 경로만 찾을 때  
- **핵심 포인트**:  
  - 재귀 기반 탐색 + 조건 분기 → 효율적으로 경우 수를 줄일 수 있음  
  - 방문 여부, 조건 체크 로직이 정확해야 불필요한 탐색을 방지 가능

## 7. 트리, 그래프, DFS/BFS 탐색
- **정의**: 정점과 간선으로 이루어진 자료구조(그래프)와 그 위에서 동작하는 탐색 알고리즘들  
- **필요 상황**: 노드 간 연결 관계 탐색, 경로 찾기, 거리 계산, 순환 여부 확인 등  
- **핵심 포인트**:  
  - DFS : 깊이 우선 탐색 → 재귀/스택  
  - BFS : 너비 우선 탐색 → 큐  
  - 문제의 구조와 요구사항에 맞는 탐색 방식 선택이 중요
